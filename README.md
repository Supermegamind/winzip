Восстановление пароля ZIP-архива 
## Описание

Лабораторная работа посвящена изучению механизмов шифрования ZIP-архивов (**ZipCrypto** и **WinZip AES-128/256**) и реализации простого инструмента для восстановления пароля методом полного перебора по заданной маске.

В репозитории два основных скрипта:

- `zip_gen.py` — генератор тестовых заданий  
- `zip_cracker.py` — программа восстановления пароля

Программа `zip_cracker.py` универсальна: умеет работать как с симулированными данными от генератора, так и с реальными `.zip`-архивами (ZipCrypto и AES).

## Требования

- Установка зависимостей:
pip install cryptography tqdm pyzipper


`pyzipper` необходим для поддержки AES-шифрования в реальных ZIP-файлах.

## zip_gen.py — Генератор тестовых заданий

### Что делает
Создаёт симулированные данные зашифрованного файла (header, ciphertext, authentication code, CRC32), полностью соответствующие спецификации WinZip.  
Данные выводятся в виде одной строки формата:

```
method_code*header*ciphertext*auth_code*crc32*compression_method
```

Все поля в hex, кроме method_code и compression_method.

### Поддерживаемые методы шифрования
- `zipcrypto` — традиционное ZipCrypto (PKWARE)
- `aes128` — WinZip AES-128
- `aes256` — WinZip AES-256 (по умолчанию)

### Алгоритмы и формулы
- **ZipCrypto**:
  - Потоковый шифр на основе трёх 32-битных ключей.
  - Инициализация: `key0 = 0x12345678`, `key1 = 0x23456789`, `key2 = 0x34567890`.
  - Обновление ключей по байтам пароля с использованием CRC32-таблицы.
  - Генерация байта потока: `temp = (key2 | 2); byte = (temp * (temp ^ 1)) >> 8`.
  - Проверка: два байта из CRC32 открытого текста в заголовке.
- **AES (WinZip)**:
  - Ключи из PBKDF2-HMAC-SHA1 (1000 итераций).
  - Размер derived key: 2 × key_len + 2 байта (ключ шифрования + ключ HMAC + 2 байта verification).
  - Шифрование: AES-CTR (IV = 0).
  - Аутентификация: HMAC-SHA1(ciphertext)[:10].
  - Verification value — последние 2 байта derived key.
  - Сжатие: Deflate (zlib).

### Запуск

```
python zip_gen.py -p <пароль> [-m <метод>] [-o <файл_вывода>]
```

Примеры:

```
python zip_gen.py -p secret123 -o task_aes256.txt
python zip_gen.py -p 12345 -m zipcrypto -o task_zipcrypto.txt
python zip_gen.py -p mypass -m aes128 -o task_aes128.txt
```


## zip_cracker.py — Восстановление пароля

### Что делает
Перебирает пароли по заданной маске и проверяет их корректность.  
Автоматически определяет тип входных данных:

- Если файл имеет расширение `.zip` → работает с реальным архивом.
- Иначе → считает, что это симулированные данные от `zip_gen.py`.

### Поддержка
- Симулированные данные: полная проверка (header, ciphertext, auth, CRC32).
- Реальные ZIP:
  - ZipCrypto → встроенный `zipfile`.
  - AES → `pyzipper` (полная дешифровка и чтение содержимого).

### Маски для перебора
- `d` — цифры 0–9
- `l` — строчные буквы a–z
- `u` — заглавные буквы A–Z
- `a` — все алфавитно-цифровые символы (a–z A–Z 0–9)

Примеры масок:
- `ddddd` — все 5-значные числа 
- `llll` — 4 строчные буквы
- `aaddd` — 2 любых символа + 3 цифры

### Запуск

```
python zip_cracker.py -m <маска> <входной_файл> [-p <процессов>] [-q]
```

Примеры:

```
# Симулированное задание
python zip_cracker.py -m ddddd task_aes256.txt

# Реальный ZIP с ZipCrypto
python zip_cracker.py -m ddddd omg.zip -p 8

# Реальный ZIP с AES
python zip_cracker.py -m ddddd omga.zip -p 8

# Тихий режим
python zip_cracker.py -m llllll task.txt -q
```

Программа выводит прогресс-бар, скорость и при нахождении пароля — детальную статистику.

### Параллелизация
Используется `multiprocessing` (по умолчанию — число ядер CPU).  
На Windows используется контекст `spawn` для совместимости.

## Примечания
- Для реальных ZIP с AES обязательно установите `pyzipper`.
- Пароли в примерах должны быть достаточно простыми (до 10⁶–10⁷ комбинаций), чтобы перебор завершался за разумное время.
- Ложные срабатывания практически исключены благодаря полной проверке (чтение содержимого + CRC).
